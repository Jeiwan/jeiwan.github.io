<!DOCTYPE html>
<html lang="en">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Ivan Kuznetsov">
<meta name="description" content="Thoughts about web development, devops, and blockchain">
<meta name="generator" content="Hugo 0.54.0" />
<title>Building Blockchain in Go. Part 2: Proof-of-Work &middot; Going the distance</title>
<link rel="shortcut icon" href="https://jeiwan.net/images/favicon.ico">
<link rel="stylesheet" href="https://jeiwan.net/css/style.css">
<link rel="stylesheet" href="https://jeiwan.net/css/highlight.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">




<meta property="og:title" content="Building Blockchain in Go. Part 2: Proof-of-Work" />
<meta property="og:description" content="Chinese translations: by liuchengxu, by zhangli1.
 Introduction In the previous article we built a very simple data structure, which is the essence of blockchain database. And we made it possible to add blocks to it with the chain-like relation between them: each block is linked to the previous one. Alas, our blockchain implementation has one significant flaw: adding blocks to the chain is easy and cheap. One of the keystones of blockchain and Bitcoin is that adding new blocks is a hard work." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jeiwan.net/posts/building-blockchain-in-go-part-2/" />
<meta property="article:published_time" content="2017-08-22T12:42:19&#43;07:00"/>
<meta property="article:modified_time" content="2017-08-22T12:42:19&#43;07:00"/>



<meta itemprop="name" content="Building Blockchain in Go. Part 2: Proof-of-Work">
<meta itemprop="description" content="Chinese translations: by liuchengxu, by zhangli1.
 Introduction In the previous article we built a very simple data structure, which is the essence of blockchain database. And we made it possible to add blocks to it with the chain-like relation between them: each block is linked to the previous one. Alas, our blockchain implementation has one significant flaw: adding blocks to the chain is easy and cheap. One of the keystones of blockchain and Bitcoin is that adding new blocks is a hard work.">


<meta itemprop="datePublished" content="2017-08-22T12:42:19&#43;07:00" />
<meta itemprop="dateModified" content="2017-08-22T12:42:19&#43;07:00" />
<meta itemprop="wordCount" content="1721">



<meta itemprop="keywords" content="Golang,Blockchain,Bitcoin," />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Building Blockchain in Go. Part 2: Proof-of-Work"/>
<meta name="twitter:description" content="Chinese translations: by liuchengxu, by zhangli1.
 Introduction In the previous article we built a very simple data structure, which is the essence of blockchain database. And we made it possible to add blocks to it with the chain-like relation between them: each block is linked to the previous one. Alas, our blockchain implementation has one significant flaw: adding blocks to the chain is easy and cheap. One of the keystones of blockchain and Bitcoin is that adding new blocks is a hard work."/>
<meta name="twitter:site" content="@https://twitter.com/jeiwan7"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='https://jeiwan.net'> <span class="arrow">‚Üê</span>Home</a>
	

	

	
</nav>

    <section id="wrapper">
        
        

<article class="post">
    <header>
        <h1>Building Blockchain in Go. Part 2: Proof-of-Work</h1>
        <h2 class="headline">
        August 22, 2017
        <br>
        
        
            
                <a href="https://jeiwan.net/tags/golang">Golang</a>
            
                <a href="https://jeiwan.net/tags/blockchain">Blockchain</a>
            
                <a href="https://jeiwan.net/tags/bitcoin">Bitcoin</a>
            
        
        
        </h2>
    </header>

    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-1399481731021488",
              enable_page_level_ads: true
         });
    </script>

    <section id="post-body">
        

<blockquote>
<p>Chinese translations: <a href="https://github.com/liuchengxu/blockchain-tutorial/blob/master/content/part-2/proof-of-work.md">by liuchengxu</a>, <a href="https://zhangli1.gitbooks.io/dummies-for-blockchain/content/">by zhangli1</a>.</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>In <a href="https://jeiwan.net/posts/building-blockchain-in-go-part-1/">the previous article</a> we built a very simple data structure, which is the essence of blockchain database. And we made it possible to add blocks to it with the chain-like relation between them: each block is linked to the previous one. Alas, our blockchain implementation has one significant flaw: adding blocks to the chain is easy and cheap. One of the keystones of blockchain and Bitcoin is that adding new blocks is a hard work. Today we&rsquo;re going to fix this flaw.</p>

<h2 id="proof-of-work">Proof-of-Work</h2>

<p>A key idea of blockchain is that one has to perform some hard work to put data in it. It is this hard work that makes blockchain secure and consistent. Also, a reward is paid for this hard work (this is how people get coins for mining).</p>

<p>This mechanism is very similar to the one from real life: one has to work hard to get a reward and to sustain their life. In blockchain, some participants (miners) of the network work to sustain the network, to add new blocks to it, and get a reward for their work. As a result of their work, a block is incorporated into the blockchain in a secure way, which maintains the stability of the whole blockchain database. It&rsquo;s worth noting that, the one who finished the work has to prove this.</p>

<p>This whole &ldquo;do hard work and prove&rdquo; mechanism is called proof-of-work. It&rsquo;s hard because it requires a lot of computational power: even high performance computers cannot do it quickly. Moreover, the difficulty of this work increases from time to time to keep new blocks rate at about 6 blocks per hour. In Bitcoin, the goal of such work is to find a hash for a block, that meets some requirements. And it&rsquo;s this hash that serves as a proof. Thus, finding a proof is the actual work.</p>

<p>One last thing to note. Proof-of-Work algorithms must meet a requirement: doing the work is hard, but verifying the proof is easy. A proof is usually handed to someone else, so for them, it shouldn&rsquo;t take much time to verify it.</p>

<h2 id="hashing">Hashing</h2>

<p>In this paragraph, we&rsquo;ll discuss hashing. If you&rsquo;re familiar with the concept, you can skip this part.</p>

<p>Hashing is a process of obtaining a hash for specified data. A hash is a unique representation of the data it was calculated on. A hash function is a function that takes data of arbitrary size and produces a fixed size hash. Here are some key features of hashing:</p>

<ol>
<li>Original data cannot be restored from a hash. Thus, hashing is not encryption.</li>
<li>Certain data can have only one hash and the hash is unique.</li>
<li>Changing even one byte in the input data will result in a completely different hash.</li>
</ol>

<p><img src="/images/hashing-example.png" alt="Hashing example" /></p>

<p>Hashing functions are widely used to check the consistency of data. Some software providers publish checksums in addition to a software package. After downloading a file you can feed it to a hashing function and compare produced hash with the one provided by the software developer.</p>

<p>In blockchain, hashing is used to guarantee the consistency of a block. The input data for a hashing algorithm contains the hash of the previous block, thus making it impossible (or, at least, quite difficult) to modify a block in the chain: one has to recalculate its hash and hashes of all the blocks after it.</p>

<h2 id="hashcash">Hashcash</h2>

<p>Bitcoin uses <a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a>, a Proof-of-Work algorithm that was initially developed to prevent email spam. It can be split into the following steps:</p>

<ol>
<li>Take some publicly known data (in case of email, it&rsquo;s receiver&rsquo;s email address; in case of Bitcoin, it&rsquo;s block headers).</li>
<li>Add a counter to it. The counter starts at 0.</li>
<li>Get a hash of the <code>data + counter</code> combination.</li>
<li>Check that the hash meets certain requirements.

<ol>
<li>If it does, you&rsquo;re done.</li>
<li>If it doesn&rsquo;t, increase the counter and repeat the steps 3 and 4.</li>
</ol></li>
</ol>

<p>Thus, this is a brute force algorithm: you change the counter, calculate a new hash, check it, increment the counter, calculate a hash, etc. That&rsquo;s why it&rsquo;s computationally expensive.</p>

<p>Now let&rsquo;s look closer at the requirements a hash has to meet. In the original Hashcash implementation, the requirement sounds like &ldquo;first 20 bits of a hash must be zeros&rdquo;. In Bitcoin, the requirement is adjusted from time to time, because, by design, a block must be generated every 10 minutes, despite computation power increasing with time and more and more miners joining the network.</p>

<p>To demonstrate this algorithm, I took the data from the previous example (&ldquo;I like donuts&rdquo;) and found a hash that starts with 3 zero-bytes:</p>

<p><img src="/images/hashcash-example.png" alt="Hashcash example" /></p>

<p><code>ca07ca</code> is the hexadecimal value of the counter, which is 13240266 in the decimal system.</p>

<h2 id="implementation">Implementation</h2>

<p>Ok, we&rsquo;re done with the theory, let&rsquo;s write code! First, let&rsquo;s define the difficulty of mining:</p>

<pre><code class="language-go">const targetBits = 24
</code></pre>

<p>In Bitcoin, &ldquo;target bits&rdquo; is the block header storing the difficulty at which the block was mined. We won&rsquo;t implement a target adjusting algorithm, for now, so we can just define the difficulty as a global constant.</p>

<p>24 is an arbitrary number, our goal is to have a target that takes less than 256 bits in memory. And we want the difference to be significant enough, but not too big, because the bigger the difference the more difficult it&rsquo;s to find a proper hash.</p>

<pre><code class="language-go">type ProofOfWork struct {
	block  *Block
	target *big.Int
}

func NewProofOfWork(b *Block) *ProofOfWork {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))

	pow := &amp;ProofOfWork{b, target}

	return pow
}
</code></pre>

<p>Here create <code>ProofOfWork</code> structure that holds a pointer to a block and a pointer to a target. &ldquo;target&rdquo; is another name for the requirement described in the previous paragraph. We use a <a href="https://golang.org/pkg/math/big/">big</a> integer because of the way we&rsquo;ll compare a hash to the target: we&rsquo;ll convert a hash to a big integer and check if it&rsquo;s less than the target.</p>

<p>In the <code>NewProofOfWork</code> function, we initialize a <code>big.Int</code> with the value of 1 and shift it left by <code>256 - targetBits</code> bits. <code>256</code> is the length of a SHA-256 hash in bits, and it&rsquo;s SHA-256 hashing algorithm that we&rsquo;re going to use. The hexadecimal representation of <code>target</code> is:</p>

<pre><code>0x10000000000000000000000000000000000000000000000000000000000
</code></pre>

<p>And it occupies 29 bytes in memory. And here&rsquo;s its visual comparison with the hashes from the previous examples:</p>

<pre><code>0fac49161af82ed938add1d8725835cc123a1a87b1b196488360e58d4bfb51e3
0000010000000000000000000000000000000000000000000000000000000000
0000008b0f41ec78bab747864db66bcb9fb89920ee75f43fdaaeb5544f7f76ca
</code></pre>

<p>The first hash (calculated on &ldquo;I like donuts&rdquo;) is bigger than the target, thus it&rsquo;s not a valid proof of work. The second hash (calculated on &ldquo;I like donutsca07ca&rdquo;) is smaller than the target, thus it&rsquo;s a valid proof.</p>

<p>You can think of a target as the upper boundary of a range: if a number (a hash) is lower than the boundary, it&rsquo;s valid, and vice versa. Lowering the boundary will result in fewer valid numbers, and thus, more difficult work required to find a valid one.</p>

<p>Now, we need the data to hash. Let&rsquo;s prepare it:</p>

<pre><code class="language-go">func (pow *ProofOfWork) prepareData(nonce int) []byte {
	data := bytes.Join(
		[][]byte{
			pow.block.PrevBlockHash,
			pow.block.Data,
			IntToHex(pow.block.Timestamp),
			IntToHex(int64(targetBits)),
			IntToHex(int64(nonce)),
		},
		[]byte{},
	)

	return data
}
</code></pre>

<p>This piece is straightforward: we just merge block fields with the target and nonce. <code>nonce</code> here is the counter from the Hashcash description above, this is a cryptographic term.</p>

<p>Ok, all preparations are done, let&rsquo;s implement the core of the PoW algorithm:</p>

<pre><code class="language-go">func (pow *ProofOfWork) Run() (int, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := 0

	fmt.Printf(&quot;Mining the block containing \&quot;%s\&quot;\n&quot;, pow.block.Data)
	for nonce &lt; maxNonce {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		fmt.Printf(&quot;\r%x&quot;, hash)
		hashInt.SetBytes(hash[:])

		if hashInt.Cmp(pow.target) == -1 {
			break
		} else {
			nonce++
		}
	}
	fmt.Print(&quot;\n\n&quot;)

	return nonce, hash[:]
}
</code></pre>

<p>First, we initialize variables: <code>hashInt</code> is the integer representation of <code>hash</code>; <code>nonce</code> is the counter. Next, we run an &ldquo;infinite&rdquo; loop: it&rsquo;s limited by <code>maxNonce</code>, which equals to <code>math.MaxInt64</code>; this is done to avoid a possible overflow of <code>nonce</code>. Although the difficulty of our PoW implementation is too low for the counter to overflow, it&rsquo;s still better to have this check, just in case.</p>

<p>In the loop we:</p>

<ol>
<li>Prepare data.</li>
<li>Hash it with SHA-256.</li>
<li>Convert the hash to a big integer.</li>
<li>Compare the integer with the target.</li>
</ol>

<p>As easy as it was explained earlier. Now we can remove the <code>SetHash</code> method of <code>Block</code> and modify the <code>NewBlock</code> function:</p>

<pre><code class="language-go">func NewBlock(data string, prevBlockHash []byte) *Block {
	block := &amp;Block{time.Now().Unix(), []byte(data), prevBlockHash, []byte{}, 0}
	pow := NewProofOfWork(block)
	nonce, hash := pow.Run()

	block.Hash = hash[:]
	block.Nonce = nonce

	return block
}
</code></pre>

<p>Here you can see that <code>nonce</code> is saved as a <code>Block</code> property. This is necessary because <code>nonce</code> is required to verify a proof. The <code>Block</code> structure now looks so:</p>

<pre><code class="language-go">type Block struct {
	Timestamp     int64
	Data          []byte
	PrevBlockHash []byte
	Hash          []byte
	Nonce         int
}
</code></pre>

<p>Alright! Let&rsquo;s run the program to see if everything works fine:</p>

<pre><code>Mining the block containing &quot;Genesis Block&quot;
00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Mining the block containing &quot;Send 1 BTC to Ivan&quot;
00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Mining the block containing &quot;Send 2 more BTC to Ivan&quot;
000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe

Prev. hash:
Data: Genesis Block
Hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1

Prev. hash: 00000041662c5fc2883535dc19ba8a33ac993b535da9899e593ff98e1eda56a1
Data: Send 1 BTC to Ivan
Hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804

Prev. hash: 00000077a856e697c69833d9effb6bdad54c730a98d674f73c0b30020cc82804
Data: Send 2 more BTC to Ivan
Hash: 000000b33185e927c9a989cc7d5aaaed739c56dad9fd9361dea558b9bfaf5fbe
</code></pre>

<p>Yay! You can see that every hash now starts with three zero bytes, and it takes some time to get these hashes.</p>

<p>There&rsquo;s one more thing left to do: let&rsquo;s make it possible to validate proof of works.</p>

<pre><code class="language-go">func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int

	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])

	isValid := hashInt.Cmp(pow.target) == -1

	return isValid
}
</code></pre>

<p>And this is where we need the saved nonce.</p>

<p>Let&rsquo;s check one more time that everything&rsquo;s ok:</p>

<pre><code class="language-go">func main() {
	...

	for _, block := range bc.blocks {
		...
		pow := NewProofOfWork(block)
		fmt.Printf(&quot;PoW: %s\n&quot;, strconv.FormatBool(pow.Validate()))
		fmt.Println()
	}
}
</code></pre>

<p>Output:</p>

<pre><code>...

Prev. hash:
Data: Genesis Block
Hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
PoW: true

Prev. hash: 00000093253acb814afb942e652a84a8f245069a67b5eaa709df8ac612075038
Data: Send 1 BTC to Ivan
Hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
PoW: true

Prev. hash: 0000003eeb3743ee42020e4a15262fd110a72823d804ce8e49643b5fd9d1062b
Data: Send 2 more BTC to Ivan
Hash: 000000e42afddf57a3daa11b43b2e0923f23e894f96d1f24bfd9b8d2d494c57a
PoW: true
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Our blockchain is a step closer to its actual architecture: adding blocks now requires hard work, thus mining is possible. But it still lacks some crucial features: the blockchain database is not persistent, there are no wallets, addresses, transactions, and there&rsquo;s no consensus mechanism. All these things we&rsquo;ll implement in future articles, and for now, happy mining!</p>

<hr />

<p>Links:</p>

<ol>
<li><a href="https://github.com/Jeiwan/blockchain_go/tree/part_2">Full source codes</a></li>
<li><a href="https://en.bitcoin.it/wiki/Block_hashing_algorithm">Blockchain hashing algorithm</a></li>
<li><a href="https://en.bitcoin.it/wiki/Proof_of_work">Proof of work</a></li>
<li><a href="https://en.bitcoin.it/wiki/Hashcash">Hashcash</a></li>
</ol>

    </section>
</article>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-1399481731021488"
    data-ad-slot="9323059516"
    data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<footer id="post-meta" class="clearfix">
    <a href="https://twitter.com/jeiwan7">
    <img class="avatar" src="https://jeiwan.net/images/avatar.png">
    <div>
        <span class="dark">Ivan Kuznetsov</span>
        <span>Golang and Clojure developer and DevOps interested in blockchain technologies</span>
    </div>
    </a>
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=Building%20Blockchain%20in%20Go.%20Part%202%3a%20Proof-of-Work - https%3a%2f%2fjeiwan.net%2fposts%2fbuilding-blockchain-in-go-part-2%2f"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>



<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/posts/programming-bitcoin-network/">Programming the Bitcoin Network<aside class="dates">Oct 30 2019</aside></a>
        </li>
    
        <li>
            <a href="/posts/what-is-lightning-network/">What is Lightning Network and How to Try It Today<aside class="dates">Mar 2 2018</aside></a>
        </li>
    
        <li>
            <a href="/posts/building-blockchain-in-go-part-7/">Building Blockchain in Go. Part 7: Network<aside class="dates">Oct 6 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/building-blockchain-in-go-part-6/">Building Blockchain in Go. Part 6: Transactions 2<aside class="dates">Sep 18 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/building-blockchain-in-go-part-5/">Building Blockchain in Go. Part 5: Addresses<aside class="dates">Sep 11 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/building-blockchain-in-go-part-4/">Building Blockchain in Go. Part 4: Transactions 1<aside class="dates">Sep 4 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/building-blockchain-in-go-part-3/">Building Blockchain in Go. Part 3: Persistence and CLI<aside class="dates">Aug 29 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/building-blockchain-in-go-part-1/">Building Blockchain in Go. Part 1: Basic Prototype<aside class="dates">Aug 16 2017</aside></a>
        </li>
    
        <li>
            <a href="/posts/til-convolution-filters-are-weights/">TIL: Convolutional Filters Are Weights<aside class="dates">Aug 5 2017</aside></a>
        </li>
    
</ul>



        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({
                google_ad_client: "ca-pub-1399481731021488",
                enable_page_level_ads: true
            });
        </script>

        <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://github.com/Jeiwan">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="https://t.me/jeiwan">
        <i class="fa fa-telegram"></i>
    </a>
    
    <a class="symbol" href="https://twitter.com/jeiwan7">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
    
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />Content of this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://jeiwan.net/js/main.js"></script>
<script src="https://jeiwan.net/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-77183580-3', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
